Cell 39 (markdown):
# Часть 3. Numpy (6 баллов), сдача в систему проверки

<font color="white" style="opacity:0.2025"></font>
================================================================================
Cell 40 (code):
import numpy as np
================================================================================
Cell 41 (markdown):
<font color='OrangeRed'>**Внимание!**</font>

* Файлы research_functions.py и research_functions_vectorised.py с реализованными функциями необходимо <font color='OrangeRed'>сдать на тестирование</font> в проверяющей системе.
================================================================================
Cell 42 (markdown):
### <font color='DarkOrange'>**Задачи 1-5 [5 баллов]**</font>

Для каждой из задач ниже привидите 2 реализации: одна без использования numpy, а вторая полностью векторизованная (**без использования циклов/map/list comprehension**). Реализации без использования векторизации нужно записать в файл research_functions.py, а векторизованные — в файл research_functions_vectorised.py (см. шаблоны).

<font color='OrangeRed'>**Внимание!**</font>

Векторизованные реализации с использованием циклов/map/list comprehension оцениваются в <font color='OrangeRed'>0 баллов</font>.

    *   Невекторизованные варианты оцениваются - по 0.3 балла
    *   Векторизованные варианты - по 0.7 балла
================================================================================
Cell 43 (markdown):
* <font color='DarkOrange'>**Задача 1**</font>: Даны два вектора x и y. Проверить, задают ли они одно и то же мультимножество.

   <font color='RosyBrown'>**Пример**</font>
      Input: x = [1, 2, 2, 4], y = [4, 2, 1, 2]
      Output: True
  

* <font color='DarkOrange'>**Задача 2**</font>: Найти максимальное прозведение соседних элементов в массиве x, таких что хотя бы один множитель в произведении делится на 3. Если таких произведений нет, то вернуть -1.

  <font color='RosyBrown'>**Пример**</font>
  
      Input: x = [6, 2, 0, 3, 0, 0, 5, 7, 0]
      Output: 12


* <font color='DarkOrange'>**Задача 3**</font>: Дан трёхмерный массив image, содержащий изображение, размера (height, width, num_channels), а также вектор весов weights длины num_channels. Сложить каналы изображения с указанными весами, и вернуть результат в виде матрицы размера (height, width). ***Обратите внимание, что в изображении может быть не три канала!***

  <font color='RosyBrown'>**Пример**</font>
  
      Input: image = [[[1, 1, 1], [2, 2, 2], [3, 3, 3]], [[4, 4, 4], [5, 5, 5], [6, 6, 6]], [[7, 7, 7], [8, 8, 8], [9, 9, 9]]], weights= [1, 2, 3]
      Output: [[6, 12, 18], [24, 30, 36], [42, 48, 54]]

  <font color='RosyBrown'>**Комментарий**</font>
  - В примере исходное изображение с тремя каналами, где по всем каналам значения равны [[1, 2, 3], [4, 5, 6], [7, 8, 9]].
  - После умножения первого канала на вес 1 получим значения для первого канала [[1, 2, 3], [4, 5, 6], [7, 8, 9]].
  - После умножения второго канала на вес 2 получим значения для второго канала [[2, 4, 6], [8, 10, 12], [14, 16, 18]].
  - После умножения третьего канала на вес 3 получим значения для третьего канала [[3, 6, 9], [12, 15, 18], [21, 24, 27]].
  - Если сложить полученное изображение поканально получим [[6, 12, 18], [24, 30, 36], [42, 48, 54]].



* <font color='DarkOrange'>**Задача 4**</font>: Найти скалярное произведение между векторами x и y, заданными в формате RLE (Run-length encoding, кодирование длин серий). Каждый закодированный вектор представлен двумерным массивом, каждая строка которого имеет размерность 2, где первое число - элемент, а второе число - сколько раз элемент нужно повторить. Например, [[1,2], [2, 3], [3, 1]] соответствует веткору [1, 1, 2, 2, 2, 3]. В случае несовпадения длин исходных векторов вернуть -1.

  <font color='RosyBrown'>**Пример**</font>
  
      Input: x = [[1, 2], [2, 3], [3, 1]], y = [[1, 1], [0, 5]].
      Output: 1

* <font color='DarkOrange'>**Задача 5**</font>: Даны две выборки объектов - X и Y. Вычислить матрицу косинусных расстояний между объектами X и Y. Пусть X - матрица n объектов размера (n, d), Y - матрица из m объектов размера (m, d), тогда матрица косинусных расстояний M - матрица размера (n, m), где m_ij - косинус угла между i-м объектом из матрицы Х (i-ая строка) и j-м объектом из матрицы Y (j-ая строка матрицы Y). Если хотя бы один из векторов равен 0, то косинусное расстояние определим равным 1.

  <font color='RosyBrown'>**Пример**</font>
  
      Input: X = [[0, 0, 0], [1, 0, 0]], Y = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
      Output: [[1, 1, 1], [1, 0, 0]]


<font color='OrangeRed'>**Примечание**</font> Можно считать, что все входные данные непустые и коректные.
================================================================================
Cell 44 (markdown):
----
================================================================================
Cell 45 (markdown):
<font color='OrangeRed'>**Внимание!**</font>
* Следующее задание оценивается по системе <font color='OrangeRed'>кросс-рецензирования</font>.
================================================================================
Cell 46 (markdown):
### <font color='DarkOrange'>**Задача 6 [1 балл]**</font>

*  <font color='DarkOrange'>**(0.5 балла)**</font> Для каждой задачи сравните скорость работы невекторизованной и векторизованной реализации. Для этого постройте графики времени работы векторизованной и невекторизованной реализации в зависимости от размера данных (`line plot`). Код генерации данных разных размеров и функция для замера времени работы функций уже написаны.
*  <font color='DarkOrange'>**(0.5 баллa)**</font>  Сделайте выводы о времени работы функций.
================================================================================
Cell 47 (markdown):
<font color='OrangeRed'>**Внимание!**</font> В текущую директорию необходимо загрузить файлы  research_functions.py и research_functions_vectorised.py с реализованными функциями. В Google Colab это можно сделать, нажав на значок "папки" слева, дальше на "загрузить" (значок листа со стрелкой вверх). Загружать нужно в папку "sample_data" (она у вас откроется по умолчанию)
================================================================================
Cell 48 (code):
import time
import numpy as np

import research_functions_vectorised
import research_functions
================================================================================
